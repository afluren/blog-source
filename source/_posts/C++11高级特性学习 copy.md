---
title: C++11高级特性学习 copy
date: 2025-02-27 23:40:18
categories: C++
tags: 
- C++
- C++11
- 学习笔记
katex: true
---
>参考的代码库是[boot-camp](https://github.com/cmu-db/15445-bootcamp)
# References and Move Semantics
---
主要讲了引用和移动操作。
**引用**就是数据的别名，和该数据的变量指向同一块地址。重头戏是这里的**移动（Move）**
#### LValue、RValue
在说移动之前先解释一下**左值引用（Lvalue）** 和**右值引用（Rvalue）**。左值引用是一个变量，可以有具体的指针，是一个变量，可以被具体存储。右值引用是暂时变量的引用，它代表的是数据本身。
它俩的区别在于，如果一个左值对另一个左值赋值，一般的效果是浅拷贝。但是一个左值对另一个右值赋值，就相当于把这个右值的数据的所有权给了这个右值。
从结果上看，浅拷贝就是一般的浅拷贝，而给所有权是如果这个右值原来有左值，那么原先的左值就不再指向这个右值数据（因为它的所有权给了新的左值）

#### Move
上述我们提到了所有权的转移，这就是移动语义。也就是说，我们不再是复制，而是把数据的所有权**移动**到了新的左值。然后有一个`move`方法，需要在`<utility>`库里引入，作用是将左值强制转变成右值引用。

没有了，大概？

我们可以说明一下这里文件里给的示例。对于赋值除了一般的浅拷贝的复制赋值，还有一种的移动赋值。上述的给左值赋右值，调用的是移动赋值。
深入下去就是`Class &operator =(Class && myclass)`，对于一个自定义类，会有默认的赋值操作（复制、移动），而如何重载就是参数类型的区别，一个是传入左值，复制赋值；另一个是传入右值引用，移动赋值。
然后对于传入右值类型的function。虽然传入右值，但是在函数里这个右值会被当成左值使用（但是编译器知道它是作为右值传入），想要在函数里将这个右值赋给左值还需要用move来切换。
这里传入右值引用是为了告诉编译器我这个资源是右值引用，它很可能会在函数里被移动。如果你传入的是左值，那就几乎可以确认这个左值不会被影响。而传入右值就意味着是想移动它。

# C++ Templates
---
主要讲的是模板。模板这个东西其实是函数和类通用的，两者用法差不多，这里就直接讲概念就好
讲了三种模板的使用：
+ 一般的模板使用，比如单个模板：
```C++
template<typename T>
void print(T a){
	cout<<a<<endl;
}
int main(){
	print<int>(10);
	return 0;
}
```
也可以是多个模板：
```C++
template<typename T,typename U>
void print2(T a,U b){
	cout<<a<<" "<<b<<endl;
}
int main(){
	print<int,double>(10,2.5);
	return 0;
}
```
+ 空模板，也叫偏特化，可以对使用了模板的类或者函数，加上一个对某个特殊类型的模板的特化版本，就相当于是以模板类型为区分的一种重载：
```C++
template<typename T>
void print(T a){
	cout<<a<<endl;
}
template<>
void print<float>(float a){
	cout<<"this is float version："<<a<<endl;
}
int main(){
	print<int>(10);
	print<float>(3.34f);
	return 0;
}
```
+ 还有就是将模板作为参数，可以传入常值模板，用于构建函数本身：
```C++
template<bool T>
void print(int a){
	if (T)cout<<"this is true："<<a<<endl;
	else cout<<"this is false："<<a<<endl;
}
int main(){
	print<true>(10);
	print<false>(10);
}
```
这里的要点是，在你生成函数实例时，模板参数会参与构建函数基本框架，然后再将参数补到函数中，换句话说，模板参数会在编译时就被使用。
这里还有一个很有趣的实现，就是比如：
```c++
template<typename T,int Size>void print(T (&arr)[Size]){
	cout<<Size<<endl;
}
template<int Size>void print(int (&arr)[Size]){
	cout<<"this is int:"<<Size<<endl;
}
int main(){
	int arr[5]={1,2,3,5,6};
	print(arr);
	print<int>(arr);
	return 0;
}
```
这个示例有几个要点：
+ 注意这个`Size`，它是**非类型模板参数**，在这个示例里它可以自动获取数组的长度（因为你在传递参数时如此使用了它），那么它就可以作为参数使用，并且存储了数组的长度，非常方便
+ 注意这两个函数的写法，本意是想作为**偏特化**的实例，但实际上，你如果将第二个函数写成`template<int Size>void print<int>(int (&arr)[Size])`的话，会报错。原因在于，这里的模板参数非空，所以没办法显式指定特化的模板参数。只有空置模板参数，编译器才会通过显式指定参数来做偏特化。这个也是下面我要说明的情况的原因
+ 注意主函数里这两个函数的使用。理论上都应该走特化版本的输出，对吧？但实际上，第一个确实是调用了“特化”版本，但第二个却调用了第一个版本。原因就在于第二个版本并不是第一个版本的特化，它相当于一个函数重载，指定了输入函数是int数组。所以你不指定版本，编译器会使用第二种这样直接规定的函数。但是如果你指定了模板参数的种类，编译器就会去找相应的模板函数，只能找到第一个版本
+ 所以，对于这种对部分模板参数做特化的操作，要想统一起来的话最好使用`std::enable_if`来限定模板范围，具体使用有点长，这里就不说了